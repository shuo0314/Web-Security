1.Length extension attack

To prevent length extension attacks, we add an additional outer layer of a hash function and the message is only used in the inner layer. In this way, attackers can not get any information about the message, and no valid padding exists to do a length extension attacks.
The detailed process is to use the ipad to XOR with password at the beginning, then continue to do the compression function like Merkle Damgard construction, after getting the digest, the digest will be padded to be 512 bits long, and now we add an additional layer of hashing by start a new compression function, this time password XOR with the opad will be the key, and padded digest acts as the message, then we get the 256 bits tag, and this tag is used as the new token. In this way, the message is only used in the inner compression function but not the outer. Its expression is HMAC(password,x)=H(password XOR opad|| H(password XOR ipad||message)). Ipad and opad are public constants.

2.Hash collision

in good/evil file, hash collision is used to get 2 file with different behaviors but having same MD5 hash values. If same attack is put on linux package managers, it's possible signature will be verified correctly but the behavior of the programs are tempered. Because two programs are possible to have same MD5 hashes, thus the signature generated from hash values will be same. Even though two programs behave differently, the verification algorithm can't tell because of the same signature. This means that for a system relying on digital signatures to verify the integrity of programs, hash collision attack is possible to break the integrity.

3.Bleichenbacher attack

Because a big exponent will make sure that after applying exponent to the message, the result will be relatively big to N, then if we do Mod N calculation, the result will be different, the modulus will be effective. In contrast, if exponent is very small, and N is actually very big, then the message after exponent will be smaller than N, and result after Mod N will be same as the result without modulus. Losing the effect of modulus will make it more possible and much easier for attackers to find the exponent root of the message and pass the verification algorithm, thus successfully forge a fake message. Belichenbacherâ€™s attack is done on a small exponent and the length of padded message is much less than the exponent root of N. Although we may not have control on the length of message input by users, by having a large exponent will be useful to prevent the result to be relatively small to N.
